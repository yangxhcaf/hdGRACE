library(dplyr)
library(rgdal)
library(raster)
library(magrittr)
library(ggplot2)
library(spatstat)
library(sp)

# import emerging freshwater availability trends 
EmergingTrend <- raster("Z:/2.active_projects/Xander/! GIS_files/R_gis_exports/GRACE_0d05.tif")

## Part 1: Create indicator: prevalence of sustainability pillars
# Import global datasets of the three sustainability pillars
## Society - proxy of population
Population <- raster("Z:/2.active_projects/Xander/! GIS_files/R_gis_exports/POP_2015_0d05.tif")
Population[Population == 0] <- NA
## Economy - proxy of GDP
GDP <- raster("Z:/2.active_projects/Xander/! GIS_files/R_gis_exports/Kummu_GDP_0d05.tif")
GDP[GDP == 0] <- NA
## Environment - proxy of amphibian species richness
AmphSpRch <- raster("Z:/2.active_projects/Xander/! GIS_files/R_gis_exports/AmphSpRch__0d05.tif")
AmphSpRch[AmphSpRch == 0] <- NA

# load raster cell area in km2 at 0d05 resolution
CellArea <- raster("Z:/2.active_projects/Xander/! GIS_files/R_gis_exports/WGS84_cellArea_0d05res.tif")
CellArea_norm <- CellArea/max(CellArea[])

# Initialize rasters to classify the percentile distribution
PopQuantile <- raster(Population)
GDPQuantile <- raster(GDP)
BioQuantile <- raster(AmphSpRch)

# create data frames for area weighted quantiles to be calculated with
POP_Quantile_df <- cbind(as.data.frame(Population), as.data.frame(CellArea_norm))
colnames(POP_Quantile_df) <- c("POP", "AreaWgt")
GDP_Quantile_df <- cbind(as.data.frame(GDP), as.data.frame(CellArea_norm))
colnames(GDP_Quantile_df) <- c("GDP", "AreaWgt")
Bio_Quantile_df <- cbind(as.data.frame(AmphSpRch), as.data.frame(CellArea_norm))
colnames(Bio_Quantile_df) <- c("Amph", "AreaWgt")

# Create a function to create a global raster which takes a global distribution raster and reclassifies it by percentile
PercentileAssignment <- function(QuantileRaster, RawRaster, DIS_Quantile_df){
  QuantileRaster[] <- 0
  QuantileRaster[RawRaster > as.numeric(unname(weighted.quantile(DIS_Quantile_df[,1], DIS_Quantile_df[,2], 0.99, na.rm = TRUE)))] <- 1
  j = 1
  k = 0.99
  for(i in 1:98){
    j = j - 0.01
    k = k - 0.01
    QuantileRaster[RawRaster <= as.numeric(unname(weighted.quantile(DIS_Quantile_df[,1], DIS_Quantile_df[,2], j, na.rm = TRUE))) & 
                     RawRaster > as.numeric(unname(weighted.quantile(DIS_Quantile_df[,1], DIS_Quantile_df[,2], k, na.rm = TRUE)))] <- j
  }
  QuantileRaster[RawRaster < as.numeric(unname(weighted.quantile(DIS_Quantile_df[,1], DIS_Quantile_df[,2], 0.01, na.rm = TRUE)))] <- 0
  return(QuantileRaster)
}


# Reclassify population raster based on quantile using above function
PopQuantile <- PercentileAssignment(PopQuantile, Population, POP_Quantile_df)
GDPQuantile <- PercentileAssignment(GDPQuantile, GDP, GDP_Quantile_df)
AmphQuantile <- PercentileAssignment(BioQuantile, AmphSpRch, Bio_Quantile_df)

writeRaster(PopQuantile, 
            filename="Z:/2.active_projects/Xander/! GIS_files/R_gis_exports/PopQuantile_AreaWeight.tif", 
            format="GTiff", overwrite=TRUE)

writeRaster(GDPQuantile, 
            filename="Z:/2.active_projects/Xander/! GIS_files/R_gis_exports/GDPQuantile_AreaWeight.tif", 
            format="GTiff", overwrite=TRUE)

writeRaster(AmphQuantile, 
            filename="Z:/2.active_projects/Xander/! GIS_files/R_gis_exports/AmphQuantile_AreaWeight.tif", 
            format="GTiff", overwrite=TRUE)


# Average the global percentile distributions 
Prevalence <- raster(EmergingTrend)
Prevalence[] <- 0
Prevalence[] <- (PopQuantile[] + GDPQuantile[] + AmphQuantile[])/3

writeRaster(Prevalence, 
            filename="Z:/2.active_projects/Xander/! GIS_files/R_gis_exports/SustainabilityPillarPrevalence_AreaWeighted.tif", 
            format="GTiff", overwrite=TRUE)

SustainabilityPillarPrevalence <- raster("Z:/2.active_projects/Xander/! GIS_files/R_gis_exports/SustainabilityPillarPrevalence_AreaWeighted.tif")

## Part 2 Create indicator: institutional resilience capacity 
# Import global datasets of the three resilience capacity indeces
## Perceived Corruption Index
CPI_scores <- read.csv("Z:/2.active_projects/Xander/! GIS_files/Corruption/CPI_2018.csv")
Country.shp <- readOGR(dsn = "Z:/2.active_projects/Xander/! GIS_files/NaturalEarth",
                       layer = "ne_10m_admin_0_countries")
keepcols <- c("SOVEREIGNT", "ISO_A3", "ADM0_A3", "NAME", "NAME_LONG")
Country.shp <- Country.shp[,keepcols, drop = FALSE]
Country.shp <- merge(Country.shp, CPI_scores, by.x = "ISO_A3", by.y = "ISO3")
Country.shp <- Country.shp[order(-Country.shp$CPI.Score.2018),]

# Write to new shapefile so that vector shapefile can be rasterized in QGIS
writeOGR(Country.shp, dsn="E:/! GIS_files/Corruption/CPI_countries.shp", 
         layer = "CPI_countries", driver="ESRI Shapefile", overwrite_layer=TRUE)
# Rasterize exported shapefile to 0.05d resolution in QGIS (optimal performance to R) for corruption perception index
# and re-import here
Corruption <- raster("Z:/2.active_projects/Xander/! GIS_files/Corruption/CPI_0d05.tif")

## Gross national income per capita
GNIpc <- read.csv("Z:/2.active_projects/Xander/! GIS_files/Wealth/GNI_usd.csv")
Country.shp$ISO_A3 <- ifelse(Country.shp$ISO_A3 == "-99", as.character(Country.shp$ADM0_A3), as.character(Country.shp$ISO_A3))
Wealth.shp <- merge(Country.shp, GNIpc, by.x = "ISO_A3", by.y = "ID3")
Wealth.shp <- Wealth.shp[order(-Wealth.shp$GNI_usd),]
# Write to new shapefile so that vector shapefile can be rasterized in QGIS
writeOGR(Wealth.shp, dsn="Z:/2.active_projects/Xander/! GIS_files/Wealth/GNIpc.shp", 
         layer = "GNIpc", driver="ESRI Shapefile", overwrite_layer=TRUE)
# and re-import here
GNIpc_ras <- raster("Z:/2.active_projects/Xander/! GIS_files/Wealth/GNIpc_0d05.tif")

# Normalize corruption scores (high score  = low corruption; max == 1)
GoodGovernance.subind <- Corruption/100

# Normalize national wealth by World Bank threshold for high income nations 
## set wealth.ind to corr.ind in instances where national wealth is not reported
Income.subind <- GNIpc_ras/12375
Income.subind[Income.subind > 1] <- 1
## set wealth.ind to corr.ind in instances where income per capita is not reported
Income.subind[is.na(Income.subind)] <- GoodGovernance.subind[is.na(Income.subind)]



# Old method where 10 factor running average was used
# 
ProtectedAres_average <- raster::aggregate(x = ProtectedAreas, fact = 10, fun = "mean")
ProtectedAres.subind <- resample(ProtectedAres_average, EmergingTrend, method='ngb')
ProtectedAres.subind[is.na(ProtectedAres.subind)] <- 0
ProtectedAres.subind <- ProtectedAres.subind/0.3
ProtectedAres.subind[ProtectedAres.subind > 1] <- 1 

writeRaster(ProtectedAres.subind,
            filename="Z:/2.active_projects/Xander/! GIS_files/R_gis_exports/ProtectedAreas_0d5Average.tif",
            format="GTiff", overwrite=TRUE)

# Calculate combined institutional resilience of sustainability pillars
InstitutionalResilienceCapacity <- (1/3)*(GoodGovernance.subind + Income.subind + ProtectedAres.subind)

writeRaster(InstitutionalResilienceCapacity, 
            filename="Z:/2.active_projects/Xander/! GIS_files/R_gis_exports/InstitutionalResilienceCapacity.tif", 
            format="GTiff", overwrite=TRUE)

#
#
# Determine subindicator scores per country
#
#
InstitutionalResilienceCapacity <- raster("Z:/2.active_projects/Xander/! GIS_files/R_gis_exports/InstitutionalResilienceCapacity.tif")
SustainabilityPillarPrevalence <- raster("Z:/2.active_projects/Xander/! GIS_files/R_gis_exports/SustainabilityPillarPrevalence_AreaWeighted.tif")
CellArea <- raster("Z:/2.active_projects/Xander/! GIS_files/R_gis_exports/WGS84_cellArea_0d05res.tif")
CellArea_norm <- CellArea/max(CellArea[])

# import Country shapefile (add associated attribute table)
Country.shp <- readOGR(dsn = "Z:/2.active_projects/Xander/! GIS_files/NaturalEarth",
                       layer = "ne_10m_admin_0_countries")
keepcols <- c("SOVEREIGNT", "SOV_A3", "ADM0_A3", "NAME")
Country.shp <- Country.shp[,keepcols, drop = FALSE]
Country.shp <- Country.shp[order(Country.shp$ADM0_A3),]
# Create unique integer ID for each country
Country.shp$ID <- seq(1, nrow(Country.shp), 1)

# import country extents IDed to correspond to attribute table
CountryID <- raster("Z:/2.active_projects/Xander/! GIS_files/VirtualWater/CountryID.tif")
CellArea_norm[SustainabilityPillarPrevalence[] == 0] <- NA
CellArea_norm[is.na(InstitutionalResilienceCapacity[])] <- NA

# determine country scores
IntitResilCap.CellSize <- zonal(InstitutionalResilienceCapacity*CellArea_norm, CountryID, "sum") # per country
SustainPillPrev.CellSize <- zonal(SustainabilityPillarPrevalence*CellArea_norm, CountryID, "sum") # per country
Country_CellSizeSum <- zonal(CellArea_norm, CountryID, "sum")

# Assess sum of area-weighted GRACE trend per country
IntitResilCap.CellSize %<>% as.data.frame()
colnames(IntitResilCap.CellSize) <- c("ID", "IRC.cellarea")

SustainPillPrev.CellSize %<>% as.data.frame()
colnames(SustainPillPrev.CellSize) <- c("ID", "SPP.cellarea")

Country_CellSizeSum %<>% as.data.frame()
colnames(Country_CellSizeSum) <- c("ID", "Cell.size.sum")

# Merge results with Country ID table
Country.shp <- merge.data.frame(Country.shp, IntitResilCap.CellSize, by.x = "ID", by.y = "ID", all = FALSE)
Country.shp <- merge.data.frame(Country.shp, SustainPillPrev.CellSize, by.x = "ID", by.y = "ID", all = FALSE)
Country.shp <- merge.data.frame(Country.shp, Country_CellSizeSum, by.x = "ID", by.y = "ID", all = FALSE)

# Calculate area-weighted indicator scores
Country.shp$IRC_SCORE <- Country.shp$IRC.cellarea/Country.shp$Cell.size.sum
Country.shp$SPP_SCORE <- Country.shp$SPP.cellarea/Country.shp$Cell.size.sum
Country.shp_1 <- Country.shp %>% 
  # filter(Cell.size.sum > 5000) %>% 
  filter(SPP_SCORE > 0.05) %>%
  filter(IRC_SCORE > 0.05) %>% 
  filter(Cell.size.sum > 100)


# plot results
Figure.sX <- ggplot(data = Country.shp_1, aes(x = SPP_SCORE, y = IRC_SCORE)) +
  theme(panel.background = element_rect(fill = "transparent", colour = NA),
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.grid.major = element_line(colour = "white", linetype = "dashed", size = 0.5),
        legend.title = element_blank(),
        axis.text = element_text(face = "bold", size = 10, color = "black")) +
  geom_hline(yintercept = 0, size = 2) +
  geom_vline(xintercept = 0, size = 2) +
  geom_point(pch = 21, fill = "#A4A4A4", size = 5) +
  # scale_fill_distiller(palette = "PRGn")+
  # ylab(bquote('Net Annual Virtual Water Import '~(cmy^-1))) + 
  # xlab(bquote('Terrestrial Water Storage Rate of Change'~(cmy^-1))) + 
  coord_cartesian(xlim = c(0, 1), ylim = c(0, 1)) +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_reverse( expand = c(0, 0))
  # geom_text(aes(label=NAME), hjust = 0.5, vjust = 0.5, size = 2)  # use if want to see auto generated labels
Figure.sX

ggsave("C:/Users/Tom/Desktop/CellArea_figures/VulnerabilityFilter_components.png", Figure.sX, 
       dpi = 500, width = 12, height = 10, bg = "transparent")

Country.shp$VulnerabilityFilter <- ((1-Country.shp$IRC_SCORE) + Country.shp$SPP_SCORE)*0.5

## Part 2.3: Combine prevalence and resilience indicators to create vulnerability filter
# 
# initialize filter raster
Vulnerability.filter <- 0.5 * (SustainabilityPillarPrevalence + (1-InstitutionalResilienceCapacity)) # inverse of resilience indicator as vulnerability comes from low resilience

writeRaster(Vulnerability.filter, 
            filename="Z:/2.active_projects/Xander/! GIS_files/R_gis_exports/VulnerabilityFilter.tif", 
            format="GTiff", overwrite=TRUE)

# Below is to calculate Vulnerability filter global percentiles
#####
Vulnerability.Quantile <- raster(EmergingTrend)
Vulnerability_df_Quantile_df <- cbind(as.data.frame(Vulnerability.filter), as.data.frame(CellArea_norm))
colnames(Vulnerability_df_Quantile_df) <- c("Vul.Fil", "AreaWgt")

Vuln.Filt.Quantile <- PercentileAssignment(Vulnerability.Quantile, Vulnerability.filter, Vulnerability_df_Quantile_df)




#####  
# below is if country percent protected is valued
#####
#
#
#
#
#
## If country percent protected is valuable...
#
#
#
ProtectedAreas <- raster("Z:/2.active_projects/Xander/! GIS_files/WorldProtectedAreas/WDPA_binary_0d05.tif")
ProtectedAreas <- resample(ProtectedAreas, EmergingTrend, "ngb")
ProtectedAreas[is.na(ProtectedAreas)] <- 0

# Calculate area-weighted average of protected land in each country as percent of country surface area
# import country extents IDed to correspond to attribute table
CountryID <- raster("Z:/2.active_projects/Xander/! GIS_files/VirtualWater/CountryID.tif")

ProtLand.cellarea <- zonal(ProtectedAreas*CellArea_norm, CountryID, "sum")
Country_CellSizeSum <- zonal(CellArea_norm, CountryID, "sum")

ProtLand.cellarea %<>% as.data.frame()
colnames(ProtLand.cellarea) <- c("ID", "WDPA.cellarea")

Country_CellSizeSum %<>% as.data.frame()
colnames(Country_CellSizeSum) <- c("ID", "Cell.size.sum")

CountryProtectedArea <- merge.data.frame(ProtLand.cellarea, Country_CellSizeSum, by.x = "ID", by.y = "ID", all = FALSE)
CountryProtectedArea$ProtectedPercent <- CountryProtectedArea$WDPA.cellarea/CountryProtectedArea$Cell.size.sum
CountryProtectedArea$Protected_SCORE <- CountryProtectedArea$ProtectedPercent/0.3
CountryProtectedArea$Protected_SCORE <- ifelse(CountryProtectedArea$Protected_SCORE > 1, 1,
                                               CountryProtectedArea$Protected_SCORE)

# merge to Country attribute table, to convert to raster
Country.shp <- readOGR(dsn = "Z:/2.active_projects/Xander/! GIS_files/NaturalEarth",
                       layer = "ne_10m_admin_0_countries")
keepcols <- c("SOVEREIGNT", "SOV_A3", "ADM0_A3", "NAME")
Country.shp <- Country.shp[,keepcols, drop = FALSE]
Country.shp <- Country.shp[order(Country.shp$ADM0_A3),]
Country.shp$ID <- seq(1, nrow(Country.shp), 1)
Country.shp <- merge(Country.shp, CountryProtectedArea, by.x = "ID", by.y = "ID", all = FALSE)
# write to OGR for faster rasterization, then reimport raster @ 0.05degree resolution
writeOGR(Country.shp, dsn="Z:/2.active_projects/Xander/! GIS_files/WorldProtectedAreas/ProtectedLand_Score.shp", 
         layer = "ProtectedLand_Score", driver="ESRI Shapefile", overwrite_layer=TRUE)
# Rasterize exported shapefile to 0.05d resolution in QGIS (optimal performance to R) for corruption perception index
# and re-import here
ProtectedAres.subind <- raster("Z:/2.active_projects/Xander/! GIS_files/WorldProtectedAreas/CountryProtected_score.tif")
